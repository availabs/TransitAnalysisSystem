/*
 * This module is a mock of the GTFS-Realtime_Toolkit's FeedReader.
 * Rather than pull GTFS-realtime messages from a transit agency's server,
 * it pulls from the MongoDB archive of GTFS-Realtime messages.
 */
// const last100Timestamps = require('../meta/last100Timestamps')

  // The MockFeedReader's constructor:
  //   MockFeedReader (_requestedTrain, startTimestamp, endTimestamp) {

  //mockGTFSrtFeed = new MockGTFSrtFeed(null, null, 1457428587) ,
  //mockGTFSrtFeed = new MockGTFSrtFeed(null, null, 1457500000) ,
  //mockGTFSrtFeed = new MockGTFSrtFeed(null, null, 1457431189) ,
  //mockGTFSrtFeed = new MockGTFSrtFeed(null, last100Timestamps[last100Timestamps.length - 1] - 25000, last100Timestamps[0]) ,
  //mockGTFSrtFeed = new MockGTFSrtFeed(null, last100Timestamps[last100Timestamps.length - 1], last100Timestamps[90]) ,

'use strict'


const MongoClient = require('mongodb').MongoClient
let gtfsrtCursor


let dotPlaceholderRegExp = new RegExp('\u0466', 'g')

let listener

const configParams = [
  'mongoURL',
  'gtfsrtCollection',
  'trainTrackerCollection'
]

function pluck (obj, props) {
  return props.reduce((acc, prop) => {
    acc[prop] = obj[prop] || null
    return acc
  }, {})
}

function MockFeedReader (config, queryParams) {

  Object.assign(this, pluck(config, configParams))

  if (queryParams.startTimestamp && isNaN(queryParams.startTimestamp)) {
    throw Error('Timestamp must be a UNIX startTimestamp.')
  }

  if (queryParams.endTimestamp && isNaN(queryParams.endTimestamp)) {
    throw Error('Timestamp must be a UNIX endTimestamp.')
  }

  if (this.requestedTrainIDs) {
    if (!Array.isArray(this.requestedTrainIDs)) {
      this.requestedTrainIDs = [this.requestedTrainIDs]
    }
  }

  const conditions = []

  if (queryParams.startTimestamp) {
    conditions.push({ _id: { $gte : queryParams.startTimestamp } })
  }

  if (queryParams.endTimestamp) {
    conditions.push({ _id: { $gte : queryParams.endTimestamp } })
  }

  if (this.requestedTrainIDs) {
    conditions.push({
      $or: this.requestedTrainIDs.reduce(
          (acc, id) => acc.concat([
              { 'state.entity.trip_update.trip.trip_id': id },
              { 'state.entity.vehicle.trip.trip_id': id },
          ]), []
        )
    })
  }

  if (conditions.length > 1) {
    // More than one condition, link with AND
    this.mongoQueryObj = { $and: conditions }
  } else {
    // Either a single condition or none.
    this.mongoQueryObj = conditions[0] || null
  }
}


MockFeedReader.prototype.getTrainTrackerInitialState = function (cb) {

  if (!this.db) {
    return cb(new Error('No MongoDB connection.'))
  }

  let trainTrackerCollection = this.db.collection(this.trainTrackerCollection)

  trainTrackerCollection.findOne(this.mongoQueryObj, { sort: { _id: 1 } }, (err, doc) => {
    if (err) {
      console.error(err.stack || err)
      return cb(err)
    }

    return cb(null, restoreKeys(doc && doc.state))
  })
}


MockFeedReader.prototype.start = function (cb) {
  MongoClient.connect(this.mongoURL, (err, db) => {
    if(err) {
     return cb(err)
    }

    this.db = db

    gtfsrtCursor = this.db.collection('gtfsrt').find(this.mongoQueryObj, { sort: { _id: 1 } })

    return cb()
  })
}


MockFeedReader.prototype.registerListener = function (_listener) {
  if (typeof _listener !== 'function') {
    throw new Error("Listeners must be functions.")
  }

  listener = _listener
}


MockFeedReader.prototype.sendNext = function () {

  let _this = this


  gtfsrtCursor.nextObject(function (err1, item) {
    if (err1) {
      throw err1
    }

    if (item === null) {
      gtfsrtCursor.close(function (err2) {
        if (err2) {
          console.error(err2)
        }

        this.db.close()
      })
      return null
    }

    let state = restoreKeys(item.state)

    // If no specific train was requested, send the listener the data.
    if (!this.requestedTrainID || !state) {
      return listener(state)
    }

    // A specific train was requested.
    // We need to pluck the parts of the message regarding the requested train.
    let focusedMessage = { header: state.header }

    state.entity.reduce(function (acc, entity) {
      let trip_id =
        (entity && entity.trip_update && entity.trip_update.trip && entity.trip_update.trip.trip_id) ||
        (entity && entity.vehicle   && entity.vehicle.trip   && entity.vehicle.trip.trip_id)

      if (trip_id === requestedTrainID) {
        acc.push(entity)
      }

      return acc

    }, focusedMessage.entity = [])

    if (focusedMessage.entity.length) {
      return listener(focusedMessage)
    } else {
      _this.sendNext()
    }
  })
}



function restoreKeys (obj) {

  let keys = ((obj !== null) && (typeof obj === 'object')) ? Object.keys(obj) : null

  if (keys) {
    return keys.reduce(function (acc, key) {
      let restoredKey = (dotPlaceholderRegExp.test(key)) ? key.replace(dotPlaceholderRegExp, '.') : key
      acc[restoredKey] = restoreKeys(obj[key])
      return acc
    }, Array.isArray(obj) ? [] : {})
  } else {
    return obj
  }
}


module.exports = MockFeedReader
